#pragma once
/* C++ API for BVE-Reborn high performance libraries. */

/* File automatically generated by bve-build, do not modify manually */

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <new>
#include "bve_prefix.h"

namespace bve {

static const float BVE_CHUNK_SIZE = 64.0;

/**
 * The blending mode to use when rendering the mesh
 */
enum class BVE_Mesh_Blend_Mode {
  Normal,
  Additive,
};

/**
 * No idea what this does, but every mesh has one or the other.
 */
enum class BVE_Mesh_Glow_Attenuation_Mode {
  DivideExponent2,
  DivideExponent4,
};

enum class BVE_UserErrorCategory {
  Warning,
  Error,
};

struct BVE_KVPSymbols;

/**
 * C safe wrapper for [`TextureSet`](bve::load::mesh::TextureSet).
 *
 * Opaque structure which wraps a set of texture names.
 *
 * # Members
 *
 * Accessible through the "member" functions:
 * - [`BVE_Texture_Set_len`] for [`TextureSet::len`](bve::load::mesh::TextureSet::len)
 * - [`BVE_Texture_Set_add`] for [`TextureSet::add`](bve::load::mesh::TextureSet::add)
 * - [`BVE_Texture_Set_lookup`] for [`TextureSet::lookup`](bve::load::mesh::TextureSet::lookup)
 *
 * # Safety
 *
 * - Must be destroyed as part of its parent [`Loaded_Static_Mesh`].
 */
struct BVE_Texture_Set;

struct BVE_User_Error_Data {
  BVE_UserErrorCategory category;
  uint64_t line;
  char *description;
  char *description_english;
};

/**
 * C safe wrapper for an [`Option`].
 *
 * # Safety
 *
 * Reading from the `value` member is undefined behavior if `exists` is false. In practice it is zeroed.
 */
template<typename T>
struct BVE_COption {
  /**
   * Actual value inside the option. Reading this is undefined behavior if exists is false.
   */
  T value;
  /**
   * Flag if the value exists or not.
   */
  bool exists;
};

/**
 * C safe wrapper for [`Span`](bve::parse::Span).
 */
struct BVE_Span {
  BVE_COption<uint64_t> line;
};

/**
 * C safe wrapper for [`MeshErrorKind`](bve::parse::mesh::MeshErrorKind).
 *
 * # Safety
 *
 * - Only read the union value that the `tag`/`determinant` says is inside the enum.
 * - Reading another value results in UB.
 * - Must be destroyed as part of its parent [`load::mesh::Loaded_Static_Mesh`].
 */
struct BVE_Mesh_Error_Kind {
  enum class Tag : uint8_t {
    UTF8,
    OutOfBounds,
    UnknownInstruction,
    GenericCSV,
    UnknownCSV,
  };

  struct BVE_UTF8_Body {
    BVE_COption<uint64_t> column;
  };

  struct BVE_OutOfBounds_Body {
    uintptr_t idx;
  };

  struct BVE_UnknownInstruction_Body {
    const char *name;
  };

  struct BVE_GenericCSV_Body {
    const char *msg;
    const char *msg_english;
  };

  Tag tag;
  union {
    BVE_UTF8_Body utf8;
    BVE_OutOfBounds_Body out_of_bounds;
    BVE_UnknownInstruction_Body unknown_instruction;
    BVE_GenericCSV_Body generic_csv;
  };
};

/**
 * C safe wrapper for [`MeshError`](bve::parse::mesh::MeshError).
 *
 * # Safety
 *
 * - Must be destroyed as part of its parent [`load::mesh::Loaded_Static_Mesh`].
 */
struct BVE_Mesh_Error {
  BVE_Span location;
  BVE_Mesh_Error_Kind kind;
};

/**
 * C safe wrapper for [`MeshWarningKind`](bve::parse::mesh::MeshWarningKind).
 *
 * # Safety
 *
 * - Only read the union value that the `tag`/`determinant` says is inside the enum.
 * - Reading another value results in UB.
 * - Must be destroyed as part of its parent [`load::mesh::Loaded_Static_Mesh`].
 */
struct BVE_Mesh_Warning_Kind {
  enum class Tag : uint8_t {
    UselessInstruction,
  };

  struct BVE_UselessInstruction_Body {
    const char *name;
  };

  Tag tag;
  union {
    BVE_UselessInstruction_Body useless_instruction;
  };
};

/**
 * C safe wrapper for [`MeshWarning`](bve::parse::mesh::MeshWarning).
 *
 * # Safety
 *
 * - Must be destroyed as part of its parent [`load::mesh::Loaded_Static_Mesh`].
 */
struct BVE_Mesh_Warning {
  BVE_Span location;
  BVE_Mesh_Warning_Kind kind;
};

/**
 * A 3-dimensional vector.
 *
 * This type is marked as `#[repr(C)]`.
 */
template<typename S>
struct BVE_Vector3 {
  /**
   * The x component of the vector.
   */
  S x;
  /**
   * The y component of the vector.
   */
  S y;
  /**
   * The z component of the vector.
   */
  S z;
};

/**
 * A 4-dimensional vector.
 *
 * This type is marked as `#[repr(C)]`.
 */
template<typename S>
struct BVE_Vector4 {
  /**
   * The x component of the vector.
   */
  S x;
  /**
   * The y component of the vector.
   */
  S y;
  /**
   * The z component of the vector.
   */
  S z;
  /**
   * The w component of the vector.
   */
  S w;
};

/**
 * A 2-dimensional vector.
 *
 * This type is marked as `#[repr(C)]`.
 */
template<typename S>
struct BVE_Vector2 {
  /**
   * The x component of the vector.
   */
  S x;
  /**
   * The y component of the vector.
   */
  S y;
};

/**
 * All per-vertex data in a BVE mesh
 */
struct BVE_Vertex {
  BVE_Vector3<float> position;
  BVE_Vector3<float> normal;
  BVE_Vector4<uint8_t> color;
  BVE_Vector2<float> coord;
  bool double_sided;
};

/**
 * C safe wrapper for a [`Vec`].
 *
 * # Safety
 *
 * - Modifying the contents in the array is valid.
 * - Increasing `count` such that `count <= capacity` is valid.
 * - Do not manually delete/realloc the pointer. Must use the deleter for the container where this vector was found.
 */
template<typename T>
struct BVE_CVector {
  /**
   * Ptr to the array of elements
   */
  T *ptr;
  /**
   * Count of elements, do not run beyond this amount
   */
  size_t count;
  /**
   * Capacity of the underlying buffer
   */
  size_t capacity;
};

/**
 * RGB color: Unsigned 8-bit integer per channel
 */
using BVE_ColorU8RGB = BVE_Vector3<uint8_t>;

/**
 * C safe wrapper for [`Texture`](bve::load::mesh::Texture).
 */
struct BVE_Mesh_Texture {
  BVE_COption<uintptr_t> texture_id;
  BVE_COption<BVE_ColorU8RGB> decal_transparent_color;
  BVE_ColorU8RGB emission_color;
};

/**
 * RGBA color: Unsigned 8-bit integer per channel
 */
using BVE_ColorU8RGBA = BVE_Vector4<uint8_t>;

/**
 * The glow numbers to use for this mesh. Not sure how exactly this works.
 */
struct BVE_Mesh_Glow {
  BVE_Mesh_Glow_Attenuation_Mode attenuation_mode;
  uint16_t half_distance;
};

/**
 * C safe wrapper for [`Mesh`](bve::load::mesh::Mesh).
 *
 * # Safety
 *
 * - Must be destroyed as part of its parent [`Loaded_Static_Mesh`].
 */
struct BVE_Mesh {
  BVE_CVector<BVE_Vertex> vertices;
  BVE_CVector<size_t> indices;
  BVE_Mesh_Texture texture;
  BVE_ColorU8RGBA color;
  BVE_Mesh_Blend_Mode blend_mode;
  BVE_Mesh_Glow glow;
};

/**
 * C safe wrapper for [`LoadedStaticMesh`](bve::load::mesh::LoadedStaticMesh).
 *
 * # Safety
 *
 * - It and all child objects must be deleted by calling [`bve_delete_loaded_static_mesh`].
 */
struct BVE_Loaded_Static_Mesh {
  BVE_CVector<BVE_Mesh> meshes;
  BVE_Texture_Set *textures;
  BVE_CVector<BVE_Mesh_Warning> warnings;
  BVE_CVector<BVE_Mesh_Error> errors;
};

/**
 * Function pointer type for the Panic Handler.
 *
 * # Arguments
 *
 * - `void*`: The data pointer provided using [`bve_set_panic_data`]. Allowed to be null.
 * - `const char*`: String containing human readable information about the panic, including a backtrace. Will never be
 *   null.
 *
 * # Safety
 *
 * Always allow `void*` to be null. You may assume the string is never null, utf8, and null terminated.
 */
using BVE_PanicHandler = void(*)(void*, const char*);

/**
 * A 1-dimensional vector.
 *
 * This type is marked as `#[repr(C)]`.
 */
template<typename S>
struct BVE_Vector1 {
  /**
   * The x component of the vector.
   */
  S x;
};

/**
 * R color: Unsigned 8-bit integer per channel
 */
using BVE_ColorU8R = BVE_Vector1<uint8_t>;

/**
 * RG color: Unsigned 8-bit integer per channel
 */
using BVE_ColorU8RG = BVE_Vector2<uint8_t>;

/**
 * R color: Unsigned 16-bit integer per channel
 */
using BVE_ColorU16R = BVE_Vector1<uint16_t>;

/**
 * RG color: Unsigned 16-bit integer per channel
 */
using BVE_ColorU16RG = BVE_Vector2<uint16_t>;

/**
 * RGB color: Unsigned 16-bit integer per channel
 */
using BVE_ColorU16RGB = BVE_Vector3<uint16_t>;

/**
 * RGBA color: Unsigned 16-bit integer per channel
 */
using BVE_ColorU16RGBA = BVE_Vector4<uint16_t>;

/**
 * R color: 32-bit float per channel
 */
using BVE_ColorF32R = BVE_Vector1<float>;

/**
 * RG color: 32-bit float per channel
 */
using BVE_ColorF32RG = BVE_Vector2<float>;

/**
 * RGB color: 32-bit float per channel
 */
using BVE_ColorF32RGB = BVE_Vector3<float>;

/**
 * RGBA color: 32-bit float per channel
 */
using BVE_ColorF32RGBA = BVE_Vector4<float>;



extern "C" {

/**
 * Get the localization and error data for a given error. C Interface for [`mesh::MeshError`]'s implementation of
 * [`bve::parse::UserError`].
 *
 * # Safety
 *
 * - `error` must be non-null, pointing to a valid Mesh_Error
 */
BVE_User_Error_Data BVE_Mesh_Error_to_data(const BVE_Mesh_Error *error);

/**
 * Get the localization and error data for a given warnings. C Interface for [`mesh::MeshWarning`]'s implementation of
 * [`bve::parse::UserError`].
 *
 * # Safety
 *
 * - `warning` must be non-null, pointing to a valid Mesh_Warning
 */
BVE_User_Error_Data BVE_Mesh_Warnings_to_data(const BVE_Mesh_Warning *warning);

/**
 * C "member function" for [`TextureSet::add`](bve::load::mesh::TextureSet::add).
 *
 * # Safety
 *
 * - `ptr` must be non-null.
 * - `value` Must be a valid null-terminated string. Non-utf8 is permitted, though escaped.
 */
size_t BVE_Texture_Set_add(BVE_Texture_Set *ptr, const char *value);

/**
 * C "member function" for [`TextureSet::len`](bve::load::mesh::TextureSet::len).
 *
 * # Safety
 *
 * - `ptr` must be non-null.
 */
BVE_NO_DISCARD size_t BVE_Texture_Set_len(const BVE_Texture_Set *ptr);

/**
 * C "member function" for [`TextureSet::lookup`](bve::load::mesh::TextureSet::lookup).
 *
 * # Safety
 *
 * - Pointer returned points to an owned **copy** of the texture name.
 * - Returned pointer must be deleted by [`crate::bve_delete_string`].
 * - If the lookup fails, output is null.
 */
BVE_NO_DISCARD const char *BVE_Texture_Set_lookup(const BVE_Texture_Set *ptr, size_t idx);

/**
 * C Destructor for [`Loaded_Static_Mesh`].
 *
 * # Safety
 *
 * - Object provided must be able to be reassembled into a rust datastructure before being deleted. This means the
 *   invariants of all of rust's equivalent datastructure must be upheld.
 */
void bve_delete_loaded_static_mesh(BVE_Loaded_Static_Mesh *object);

/**
 * Takes an owning pointer to a rust-generated string and deletes it.
 *
 * # Safety
 *
 * - `ptr` **ASSUMES OWNERSHIP** must be a valid pointer and the string must have been allocated in Rust. It must be
 *   zero terminated.
 */
void bve_delete_string(char *ptr);

/**
 * Reads the file at `filename` with [`bve::filesystem::read_convert_utf8`].
 *
 * # Safety
 *
 * - Pointer returned points to an **owned** string containing the contents of the file in utf8.
 * - Returned pointer must be deleted by [`crate::bve_delete_string`].
 * - If file loading fails, output is null.
 */
BVE_NO_DISCARD char *bve_filesystem_read_convert_utf8(const char *filename_ptr);

/**
 * Returns the currently set data to be passed to the panic handler. May be null.
 */
void *bve_get_panic_data();

/**
 * Returns the currently set panic handler. Non-null.
 */
BVE_PanicHandler bve_get_panic_handler();

/**
 * Initialize the runtime functionality of BVE. Initializes minimal global state to make the rest
 * of the API safe to call. ***DO NOT CALL ANY OTHER FUNCTION BEFORE YOU CALL INIT***.
 *
 * This function is not protected against panics as it must not panic due to the handler not being set up.
 *
 * May be called multiple times, but all global state will be reset.
 */
void bve_init();

/**
 * C Interface for [`load_mesh_from_file`](bve::load::mesh::load_mesh_from_file).
 *
 * # Safety
 *
 * - `file` must be non-null and null terminated.
 * - Result must be properly deleted.
 */
BVE_NO_DISCARD BVE_Loaded_Static_Mesh *bve_load_mesh_from_file(const char *file);

/**
 * Sets the data passed to the panic handler.
 *
 * # Safety
 *
 * - If the installed panic handler touches this data, it must be non-null and point to the data it expects
 * - There is a minor race between this function and [`bve_set_panic_handler`]. See module documentation.
 */
void bve_set_panic_data(void *data);

/**
 * Sets the panic handler to the provided function pointer.
 *
 * # Safety
 *
 * - `handler` must not be null and must point to a valid function of the proper signature.
 * - The function `handler` points to must uphold the invariants of the contract of [`PanicHandler`]
 * - There is a minor race between this function and [`bve_set_panic_data`]. See module documentation.
 */
void bve_set_panic_handler(BVE_PanicHandler handler);

} // extern "C"

} // namespace bve
